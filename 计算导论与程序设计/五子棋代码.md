```c++
#include "stdio.h"
#include "graphics.h"
#include "conio.h"
#include "easyx.h"

FILE* fp = NULL;
char c, c1, c2;
int n = 0, n1 = 0, n2 = 0;
int now_x = 0, now_y = 0;

void button(int x, int y, int w, int h, const char* text)
{
	fillroundrect(x, y, x+w, y+h,10,10);
	setfillcolor(RGB(250, 250, 250));
	settextstyle(35, 14, "华文行楷");
	setbkmode(TRANSPARENT);
	settextcolor(RGB(0, 0, 0));
	int tx = x + (w - textwidth(text)) / 2;
	int ty = y + (h - textheight(text)) / 2;
	outtextxy(tx, ty, text);
}

void new_game()
{
	setfillcolor(RGB(250, 250, 250));
	button(520, 680, 102, 48, "返回");
	setfillcolor(RGB(176, 218, 242));
	fillrectangle(270, 620, 370, 730);
	setlinestyle(PS_SOLID | PS_ENDCAP_SQUARE, 2);
	setlinecolor(BLACK);
	rectangle(17, 17, 612, 612);
	setlinestyle(PS_SOLID, 2);
	setcolor(RGB(0, 0, 0));
	int step = 30;
	for (int i = 1; i <= 20; i++)
	{
		line(i * step, 1 * step, i * step, 20 * step);
		line(1 * step, i * step, 20 * step, i * step);
	}
}

void fall_white(int x,int y)
{
	setfillcolor(WHITE);
	solidcircle(x, y, 13);
}

void fall_black(int x,int y)
{
	setfillcolor(BLACK);
	solidcircle(x, y, 13);
}

int get(short x)
{
	for (int i = 1; i <= 20; i++)
	{
		if (x >= 30*i - 13 && x <= 30*i + 13)
		{
			return i-1;
		}
	}
	return 100;
}			
//将鼠标位置转为坐标

int check_uptodown(int x,int y,int flag[][20])
{
	int i = 0, j = 0;
	for (int k =1 ; k <= 4; k++)
	{
		if (y - k >= 0)
		{
			if (flag[x][y - k] == flag[x][y])
			{
				i++;
			}
		}
	}
	for (int k = 1; k <= 4; k++)
	{
		if (y + k <= 19)
		{
			if (flag[x][y + k] == flag[x][y])
			{
				j++;
			}
		}
	}
	if (i + j >= 4)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int check_lefttoright(int x, int y, int flag[][20])
{
	int i = 0, j = 0;
	for (int k = 1; k <= 4; k++)
	{
		if (x - k >= 0)
		{
			if (flag[x-k][y] == flag[x][y])
			{
				i++;
			}
		}
	}
	for (int k = 1; k <= 4; k++)
	{
		if (x+ k <= 19)
		{
			if (flag[x+k][y] == flag[x][y])
			{
				j++;
			}
		}
	}
	if (i + j >= 4)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int check_maindiagonal(int x, int y, int flag[][20])
{
	int i = 0, j = 0;
	for (int k = 1; k <= 4; k++)
	{
		if (y - k >= 0&&x-k>=0)
		{
			if (flag[x-k][y - k] == flag[x][y])
			{
				i++;
			}
		}
	}
	for (int k = 1; k <= 4; k++)
	{
		if (y + k <= 19&&x+k<=19)
		{
			if (flag[x+k][y + k] == flag[x][y])
			{
				j++;
			}
		}
	}
	if (i + j >= 4)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int check_secondarydia(int x, int y, int flag[][20])
{
	int i = 0, j = 0;
	for (int k = 1; k <= 4; k++)
	{
		if (y - k >= 0&&x+k<=19)
		{
			if (flag[x+k][y - k] == flag[x][y])
			{
				i++;
			}
		}
	}
	for (int k = 1; k <= 4; k++)
	{
		if (y + k <= 19&&x-k>=0)
		{
			if (flag[x-k][y + k] == flag[x][y])
			{
				j++;
			}
		}
	}
	if (i + j >= 4)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

void win_white(int flag[][20])
{
	IMAGE win;
	loadimage(&win, "win.jpg");
	putimage(3, 100, &win);
	settextstyle(50, 20, "华文行楷");
	setbkmode(TRANSPARENT);
	settextcolor(RGB(250, 250, 250));
	outtextxy(225, 100, "白方胜");

	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			flag[i][j] = 0;
		}
	}
	_getch();
	cleardevice();
	new_game();
}

void win_black(int flag[][20])
{
	IMAGE win;
	loadimage(&win, "win.jpg");
	putimage(3, 100, &win);
	settextstyle(50, 20, "华文行楷");
	setbkmode(TRANSPARENT);
	settextcolor(RGB(250, 250, 250));
	outtextxy(225, 100, "黑方胜");

	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			flag[i][j] = 0;
		}
	}
	_getch();
	cleardevice();
	new_game();
}

int weight_uptodown(int x, int y, int flag[][20])
{
	int weight = 0;
	int num = 0;
	for (int i = 1; i <= 3; i++)
	{
		if (x - i - 1 >= 0)
		{
			if (flag[x - i][y] == flag[x - i - 1][y] && flag[x - i][y] != 0)
			{
				weight+=4-i;
				num++;
			}
			else if (flag[x - i][y] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
			
		}
	}
	for (int i = 1; i <= 3; i++)
	{
		if (x + i + 1 < 20)
		{
			if(flag[x + i][y] == flag[x + i + 1][y] && flag[x + i][y] != 0)
			{
				weight+= 4 - i;
				num++;
			}
			else if(flag[x+i][y]==0)
			{
				weight += num ;
				break;
			}
			else
			{
				break;
			}
		}
	}
	if (num >= 2&&flag[x-1][y]==flag[x+1][y])
	{
		weight += num * (flag[x - 1][y] % 2 + 1);
	}
	return weight;
}

int weight_lefttoright(int x, int y, int flag[][20])
{
	int weight = 0;
	int num = 0;
	for (int i = 1; i <= 3; i++)
	{
		if (y - i - 1 >= 0)
		{
			if (flag[x][y - i] == flag[x ][y- i - 1] && flag[x][y - i] != 0)
			{
				weight += 4 - i;
				num++;
			}
			else if (flag[x][y -i] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
		}
	}
	for (int i = 1; i <= 3; i++)
	{
		if (y + i + 1 < 20)
		{
			if (flag[x][y + i] == flag[x][y + i + 1] && flag[x][y + i] != 0)
			{
				weight += 4 - i;
				num++;
			}
			else if (flag[x][y + i] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
		}
	}
	if (num >= 2&&flag[x][y-1]==flag[x][y+1])
	{
		weight += num *(flag[x][y - 1] % 2 + 1);
	}
	return weight;
}

int weight_maindiagonal(int x, int y, int flag[][20])
{
	int weight = 0;
	int num = 0;
	for (int i = 1; i <= 3; i++)
	{
		if (x - i - 1 > 0 && y - i - 1 > 0)
		{
			if (flag[x - i][y - i] == flag[x - i - 1][y - i - 1] && flag[x - i][y - i] != 0)
			{
				weight += 4 - i;
				num++;
			}
			else if (flag[x - i][y - i] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
		}
	}
	for (int i = 1; i <= 3; i++)
	{
		if (x + i + 1 < 20 && y + i + 1 < 20)
		{
			if (flag[x + i][y + i] == flag[x + i + 1][y + i + 1] && flag[x + i][y + i] != 0)
			{
				weight += 4 - i;
				num++;
			}
			else if (flag[x + i][y + i] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
		}
	}
	if (num >= 2&&flag[x-1][y-1]==flag[x+1][y+1])
	{
		weight += num * (flag[x - 1][y - 1] % 2 + 1);
	}
	return weight;
}

int weight_secondarydia(int x, int y, int flag[][20])
{
	int weight = 0;
	int num = 0;
	for (int i = 1; i <= 3; i++)
	{
		if (x - i - 1 >= 0 && y + i + 1 < 19)
		{
			if (flag[x - i][y + i] == flag[x - i - 1][y + i + 1] && flag[x - i][y + i] != 0)
			{
				weight += 4 - i;
				num++;
			}
			else if (flag[x - i][y + i] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
		}
	}
	for (int i = 1; i <= 3; i++)
	{
		if (x + i + 1 >= 0 && y - i - 1 > 0)
		{
			if (flag[x + i][y - i] == flag[x + i + 1][y - i - 1] && flag[x + i][y - i] != 0)
			{
				weight += 4 - i;
				num++;
			}
			else if (flag[x + i][y - i] == 0)
			{
				weight += num;
				break;
			}
			else
			{
				break;
			}
		}
	}
	if (num >= 2 && flag[x - 1][y+1] == flag[x + 1][y-1])
	{
		weight += num * (flag[x - 1][y + 1] % 2 + 1);
	}
	return weight;
}

void PVP(int fall_x[], int fall_y[], int FLAG[][20]);

void PVE(int fall_x[], int fall_y[], int FLAG[][20]);

void record(int fall_x[], int fall_y[], int FLAG[][20]);

int main()
{
	initgraph(630, 740);
	IMAGE imgbk;
	loadimage(&imgbk, "back.jpg", 630, 740);
	putimage(0, 0, &imgbk);

	button(50, 200, 180, 50, "双人对弈");
	button(50, 320, 180, 50, "人机对弈");
	button(50, 440, 180, 50, "观战模式");
	button(50, 560, 180, 50, "挑战记录");
	
	
	fopen_s(&fp,"game.txt", "a+");
	int fall_x[20] = { 0 };
	int fall_y[20] = { 0 };
	int r = 13;

	for (int i = 1; i <= 20; i++)       //落子坐标
	{
		fall_x[i - 1] = 30 * i;
		fall_y[i - 1] = 30 * i;
	}   
	
	while (1)
	{
		int FLAG[20][20] = { 0 };         //是否已落子
		ExMessage msg;
		peekmessage(&msg, EM_MOUSE);

		switch (msg.message)
		{
		case WM_LBUTTONDOWN:
			if (msg.x >= 50 && msg.x <= 230 && msg.y >= 200 && msg.y <= 250)
			{
				PVP(fall_x, fall_y, FLAG);
			}
			if (msg.x >= 50 && msg.x <= 230 && msg.y >= 320 && msg.y <= 370)
			{
				PVE(fall_x, fall_y, FLAG);
			}
			if (msg.x >= 50 && msg.x <= 230 && msg.y >= 440 && msg.y <= 490)
			{
				initgraph(640, 750);

				getchar();
				closegraph();
			}
			if (msg.x >= 50 && msg.x <= 230 && msg.y >= 560 && msg.y <= 610)
			{
				record(fall_x, fall_y, FLAG);
			}
		}
	}
	getchar();
	closegraph();
	return 0;
	
}

void PVP(int fall_x[], int fall_y[], int FLAG[][20])
{
	initgraph(630, 740);
	setbkcolor(RGB(209, 186, 116));
	cleardevice();
	new_game();
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			FLAG[i][j] = 0;
		}
	}

	int num = 1;
	ExMessage m1;

	while (1)
	{
		switch (num)
		{
		case 1:														//下方提示落子方
			setfillcolor(BLACK);
			solidcircle(320, 660, 35);
			settextstyle(20, 10, "黑体");
			setbkmode(TRANSPARENT);
			settextcolor(RGB(0, 0, 0));
			outtextxy(290, 700, "请落子");
			break;
		case 0:
			setfillcolor(WHITE);
			solidcircle(320, 660, 35);
			settextstyle(20, 10, "黑体");
			setbkmode(TRANSPARENT);
			settextcolor(RGB(250, 250, 250));
			outtextxy(290, 700, "请落子");
		}
		peekmessage(&m1, EM_MOUSE);
		if (m1.message == WM_LBUTTONDOWN)
		{
			if (m1.x >= 17 && m1.x <= 612 && m1.y >= 17 && m1.y <= 612)
			{
				
				now_x = get(m1.x);
				now_y = get(m1.y);
				if (num == 1 && now_x != 100 && now_y != 100 && FLAG[now_x][now_y] == 0)		
				{
					fall_black(fall_x[now_x], fall_y[now_y]);
					FLAG[now_x][now_y] = 1;
					num = 0;
					c = '1';
					fputc(c, fp);
					c1 = '0' + now_x / 10;
					c2 = '0' + now_x % 10;
					fputc(c1, fp);
					fputc(c2, fp);
					c1 = '0' + now_y / 10;
					c2 = '0' + now_y % 10;
					fputc(c1, fp);
					fputc(c2, fp);
				}
				else if (num == 0 && now_x != 100 && now_y != 100 && FLAG[now_x][now_y] == 0)   
				{
					fall_white(fall_x[now_x], fall_y[now_y]);
					FLAG[now_x][now_y] = 2;
					num = 1;
					c = '0';
					fputc(c, fp);
					c1 = '0' + now_x / 10;
					c2 = '0' + now_x % 10;
					fputc(c1, fp);
					fputc(c2, fp);
					c1 = '0' + now_y / 10;
					c2 = '0' + now_y % 10;
					fputc(c1, fp);
					fputc(c2, fp);
				}
				if (now_x != 100 && now_y != 100 && FLAG[now_x][now_y] != 0)		
				{
					int check1 = check_uptodown(now_x, now_y, FLAG);
					int check2 = check_lefttoright(now_x, now_y, FLAG);
					int check3 = check_maindiagonal(now_x, now_y, FLAG);
					int check4 = check_secondarydia(now_x, now_y, FLAG);
					if (check1 || check2 || check3 || check4)
					{
						if (FLAG[now_x][now_y] == 1)
						{
							c = 'b';
							fputc(c, fp);
							win_black(FLAG);
							num = 1;
						}
						else if (FLAG[now_x][now_y] == 2)
						{
							c = 'w';
							fputc(c, fp);
							win_white(FLAG);
							num = 0;
						}
					}
				}
			}
			else if (m1.x >= 520 && m1.x <= 622 && m1.y >= 680 && m1.y <= 728)
			{
				initgraph(630, 740);
				IMAGE imgbk;
				loadimage(&imgbk, "back.jpg", 630, 740);
				putimage(0, 0, &imgbk);

				button(50, 200, 180, 50, "双人对弈");
				button(50, 320, 180, 50, "人机对弈");
				button(50, 440, 180, 50, "观战模式");
				button(50, 560, 180, 50, "挑战记录");

				for (int i = 0; i < 20; i++)
				{
					for (int j = 0; j < 20; j++)
					{
						FLAG[i][j] = 0;
					}
				}
				
				flushmessage();
				while (1)
				{
					m1 = getmessage();
					if(m1.message== WM_LBUTTONDOWN)
					{
						if (m1.x >= 50 && m1.x <= 230 && m1.y >= 200 && m1.y <= 250)
						{
							PVP(fall_x, fall_y, FLAG);
						}
						if (m1.x >= 50 && m1.x <= 230 && m1.y >= 320 && m1.y <= 370)
						{
							PVE(fall_x, fall_y, FLAG);
						}
						if (m1.x >= 50 && m1.x <= 230 && m1.y >= 440 && m1.y <= 490)
						{
							initgraph(640, 750);

							getchar();
							closegraph();
						}
						if (m1.x >= 50 && m1.x <= 230 && m1.y >= 560 && m1.y <= 610)
						{
							record(fall_x, fall_y, FLAG);
						}
					}
				
				}
				getchar();
				closegraph();
			}
		}
	}
	getchar();
	closegraph();

}

void PVE(int fall_x[], int fall_y[], int FLAG[][20])
{
	initgraph(640, 750);
	setbkcolor(RGB(209, 186, 116));
	cleardevice();
	new_game();
	int r = 13;
	
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			FLAG[i][j] = 0;
		}
	}
	int num = 1;
	int weight[20][20];
	memset(weight, 0, sizeof(weight));
	ExMessage m2;

	while (1)
	{
		switch (num)
		{
		case 1:
			setfillcolor(BLACK);
			solidcircle(320, 660, 35);
			settextstyle(20, 10, "黑体");
			setbkmode(TRANSPARENT);
			settextcolor(RGB(0, 0, 0));
			outtextxy(290, 700, "请落子");
			break;

		case 0:
			setfillcolor(WHITE);
			solidcircle(320, 660, 35);
			settextstyle(20, 10, "黑体");
			setbkmode(TRANSPARENT);
			settextcolor(RGB(250, 250, 250));
			outtextxy(290, 700, "请落子");
			break;
		}


		if (num == 0)
		{
			for (int i = 0; i < 20; i++)
			{
				for (int j = 0; j < 20; j++)
				{
					weight[i][j] = 0;
				}
			}
			for (int i = 0; i < 20; i++)
			{
				for (int j = 0; j < 20; j++)
				{
					if (FLAG[i][j] == 0)
					{
						weight[i][j] += weight_uptodown(i, j, FLAG);
						weight[i][j] += weight_lefttoright(i, j, FLAG);
						weight[i][j] += weight_maindiagonal(i, j, FLAG);
						weight[i][j] += weight_secondarydia(i, j, FLAG);
					}
				}
			}

			int max = 0;
			int fallx = 9, fally = 9;
			for (int i = 0; i < 20; i++)
			{
				for (int j = 0; j < 20; j++)
				{
					if (weight[i][j] > max)
					{
						max = weight[i][j];
						fallx = i;
						fally = j;
					}
				}
			}
			int n = 0;
			for (int i = 0; i < 20; i++)
			{
				for (int j = 0; j < 20; j++)
				{
					n += FLAG[i][j];
				}
			}
			if (n == 1)
			{
				fallx = now_x;
				fally = now_y + 1;
			}
			else if (n == 0)
			{
				fallx = 10;
				fally = 10;
			}
			else if (n == 3)
			{
				fallx = now_x - 1;
				fally = now_y - 1;
			}
			fall_white(fall_x[fallx], fall_y[fally]);
			FLAG[fallx][fally] = 2;
			num = 1;
			c = '0';
			fputc(c, fp);
			c1 = '0' + fallx / 10;
			c2 = '0' + fallx % 10;
			fputc(c1, fp);
			fputc(c2, fp);
			c1 = '0' + fally / 10;
			c2 = '0' + fally % 10;
			fputc(c1, fp);
			fputc(c2, fp);
			int check1 = check_uptodown(fallx, fally, FLAG);
			int check2 = check_lefttoright(fallx, fally, FLAG);
			int check3 = check_maindiagonal(fallx, fally, FLAG);
			int check4 = check_secondarydia(fallx, fally, FLAG);
			if (check1 || check2 || check3 || check4)
			{
				c = 'w';
				fputc(c, fp);
				win_white(FLAG);
				num = 0;
			}
		}
		

		peekmessage(&m2, EM_MOUSE);

		if (m2.message == WM_LBUTTONDOWN)
		{
			if (m2.x >= 17 && m2.x <= 612 && m2.y >= 17 && m2.y <= 612)
			{
				now_x = get(m2.x);
				now_y = get(m2.y);
				if (num == 1 && now_x != 100 && now_y != 100 && FLAG[now_x][now_y] == 0)
				{
					fall_black(fall_x[now_x], fall_y[now_y]);
					FLAG[now_x][now_y] = 1;
					num = 0;
					c = '1';
					fputc(c, fp);
					c1 = '0' + now_x / 10;
					c2 = '0' + now_x % 10;
					fputc(c1, fp);
					fputc(c2, fp);
					c1 = '0' + now_y / 10;
					c2 = '0' + now_y % 10;
					fputc(c1, fp);
					fputc(c2, fp);
				}
				if (now_x != 100 && now_y != 100 && FLAG[now_x][now_y] != 0)
				{
					int check1 = check_uptodown(now_x, now_y, FLAG);
					int check2 = check_lefttoright(now_x, now_y, FLAG);
					int check3 = check_maindiagonal(now_x, now_y, FLAG);
					int check4 = check_secondarydia(now_x, now_y, FLAG);
					if (check1 || check2 || check3 || check4)
					{
						c = 'b';
						fputc(c, fp);
						win_black(FLAG);
						num = 1;
					}
				}
			}
			if (m2.x >= 520 && m2.x <= 622 && m2.y >= 680 && m2.y <= 728)
			{
				initgraph(630, 740);
				IMAGE imgbk;
				loadimage(&imgbk, "back.jpg", 630, 740);
				putimage(0, 0, &imgbk);

				button(50, 200, 180, 50, "双人对弈");
				button(50, 320, 180, 50, "人机对弈");
				button(50, 440, 180, 50, "观战模式");
				button(50, 560, 180, 50, "挑战记录");

				for (int i = 0; i < 20; i++)
				{
					for (int j = 0; j < 20; j++)
					{
						FLAG[i][j] = 0;
					}
				}

				flushmessage();
				while (1)
				{
					m2 = getmessage();
					if (m2.message == WM_LBUTTONDOWN)
					{
						if (m2.x >= 50 && m2.x <= 230 && m2.y >= 200 && m2.y <= 250)
						{
							PVP(fall_x, fall_y, FLAG);
						}
						if (m2.x >= 50 && m2.x <= 230 && m2.y >= 320 && m2.y <= 370)
						{
							PVE(fall_x, fall_y, FLAG);
						}
						if (m2.x >= 50 && m2.x <= 230 && m2.y >= 440 && m2.y <= 490)
						{
							initgraph(640, 750);

							getchar();
							closegraph();
						}
						if (m2.x >= 50 && m2.x <= 230 && m2.y >= 560 && m2.y <= 610)
						{
							record(fall_x, fall_y, FLAG);
						}
					}
				}
				getchar();
				closegraph();
			}
			
			
		}
		
		
	}

	getchar();
	closegraph();


}

void record(int fall_x[], int fall_y[], int FLAG[][20])
{
	initgraph(640, 750);
	setbkcolor(RGB(209, 186, 116));
	cleardevice();
	new_game();
	rewind(fp);
	c = fgetc(fp);
	while (c != EOF)
	{
		if (c <= '9' && c >= '0')
		{
			n = c - '0';
			c1 = fgetc(fp);
			c2 = fgetc(fp);
			n1 = (c1 - '0') * 10 + (c2 - '0');
			c1 = fgetc(fp);
			c2 = fgetc(fp);
			n2 = (c1 - '0') * 10 + (c2 - '0');
			if (n == 1)
			{
				fall_black(fall_x[n1], fall_y[n2]);
				system("pause");
			}
			else if (n == 0)
			{
				fall_white(fall_x[n1], fall_y[n2]);
				system("pause");
			}
		}
		else
		{
			if (c == 'b')
			{
				win_black(FLAG);
			}
			else if (c == 'w')
			{
				win_white(FLAG);
			}
		}
		c = fgetc(fp);
		ExMessage mm;
		while (c == 'b' || c == 'w')
		{
			peekmessage(&mm, EM_MOUSE);
			if (mm.message == WM_LBUTTONDOWN)
			{
				if (mm.x >= 520 && mm.x <= 622 && mm.y >= 680 && mm.y <= 728)
				{
					initgraph(630, 740);
					IMAGE imgbk;
					loadimage(&imgbk, "back.jpg", 630, 740);
					putimage(0, 0, &imgbk);

					button(50, 200, 180, 50, "双人对弈");
					button(50, 320, 180, 50, "人机对弈");
					button(50, 440, 180, 50, "观战模式");
					button(50, 560, 180, 50, "挑战记录");

					for (int i = 0; i < 20; i++)
					{
						for (int j = 0; j < 20; j++)
						{
							FLAG[i][j] = 0;
						}
					}

					flushmessage();
					while (1)
					{
						mm = getmessage();
						if (mm.message == WM_LBUTTONDOWN)
						{
							if (mm.x >= 50 && mm.x <= 230 && mm.y >= 200 && mm.y <= 250)
							{
								PVP(fall_x, fall_y, FLAG);
							}
							if (mm.x >= 50 && mm.x <= 230 && mm.y >= 320 && mm.y <= 370)
							{
								PVE(fall_x, fall_y, FLAG);
							}
							if (mm.x >= 50 && mm.x <= 230 && mm.y >= 440 && mm.y <= 490)
							{
								initgraph(640, 750);

								getchar();
								closegraph();
							}
							if (mm.x >= 50 && mm.x <= 230 && mm.y >= 560 && mm.y <= 610)
							{
								record(fall_x, fall_y, FLAG);
							}
						}
					}
					getchar();
					closegraph();
				}
				else
				{
					break;
				}
			}
		}
	}
	getchar();
	closegraph();
}

```

